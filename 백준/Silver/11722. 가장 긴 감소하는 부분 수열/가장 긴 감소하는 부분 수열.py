'''
접근 방법

ns의 어디가 가수의 가장 오른쪽값인지 모른다. 
따라서 모두가 그 오른쪽 값이 될 수 있음을 가정하고 dp를 구성한다.
dp: 그 값을 가장 오른쪽 값으로 하는 가장 긴 부분 수열의 길이 
따라서 정답은 print(max(dp))

그럼 dp를 어떻게 구성하는가?
dp의 초기 값은 1로 초기화된다. 각자 자기 값은 확실하게 카운트할 수 있기 때문이다. 
가장 왼쪽부터 오른쪽으로 치고 올라가야 구해둔 dp를 활용할 수 있다. 

ns[i]를 제일 오른쪽 값으로 한다면, 그 이전의 값의 위치를 어떻게 아는가?
그건 순차적으로 j를 증가시키면서 모두를 확인한다. 
다만 ns[j]의 값이 ns[i]보다 작은 경우 dp를 계산하고 갱신한다. 


'''

n = int(input())
ns = list(map(int, input().split()))

dp = [1] * (n + 1)
for i in range(n):
    for j in range(i):

        if ns[i] < ns[j]:

            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp))

