# [Silver II] DFS와 BFS - 1260 

[문제 링크](https://www.acmicpc.net/problem/1260) 

### 성능 요약

메모리: 15124 KB, 시간: 292 ms

### 분류

그래프 이론, 그래프 탐색, 너비 우선 탐색, 깊이 우선 탐색

### 문제 설명

<p>그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.</p>

### 입력 

 <p>첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.</p>

### 출력 

 <p>첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.</p>

### 풀이

dfs, bfs의 첫 발걸음을 떼기 위해 푼 문제다. 

dfs는 depth first searching의 약자이며 깊이 우선 탐색이라는 뜻이다. 
깊이를 우선한다는 것은 우리가 실제로 미로 공간에서 탈출구를 찾는 방식과 유사하다. 
미로의 입구에 들어서면 일단 어느 갈림길을 가던 막다른 길부터 찾게된다. 만약 막다른 길에 마주하면 유턴해 왔던 길을 다시 가는데, 왔던 길을 다시 가는 중에 제일 처음으로 만나는(제일 마지막으로 지나쳤던) 갈림길로 들어가 다시 막다른 길까지 질주한다. 이런식의 탐색을 dfs라고 한다. 

bfs는 물결이 퍼지듯 트리의 레벨 오름차순으로 방문하는 것으로 비유할 수 있겠다.(완벽한 비유는 아니다) 1레벨을 방문하기 위해선 0레벨(루트노드)를 먼저 다 방문해야하고, 2레벨을 방문하기 위해서는 1레벨 노드를 전부 방문해야한다. bfs는 이런 식이다. 

어려웠던 건 이런 탐색 방식을 코드로 옮기는 부분이다. 이건 검색으로 도움을 좀 받았다.
자료구조를 잘 이해해야 코드로 작성할 수 있었다.

일단 두 탐색법 모두 공통되는 것은 입력으로 받은 데이터를 그래프 형태로 정리해야한다는 점이다. 
여기서 그래프 형태란 가중치 없는 링크로 연결된 노드를 얘기하는데, 이는 2차원 배열로 표현할 수 있다. 

그리고 그래프 형태로 가공한 데이터로 dfs, bfs를 돌리게 된다. 

dfs는 스택을 사용하는데, 스택의 특징이란 먼저 들어온 데이터는 가장 나중에 나가게 된다는 것이다. 이런 특징이 왜 dfs에서 사용되는지 생각해보자.
시작 노드를 스택에 넣는다. 이렇게 시작 노드를 방문했다면 스택에서 팝함과 동시에 시작 노드에 연결되어있는 인접 노드를 스택에 넣어야 한다. 
이때 스택의 탑쪽에는 바로 다음 방문할 노드를 위치시켜야 한다. 그리고 다시 팝하면 인접 노드의 인접 노드(시작 노드에서 2링크 떨어진)를 앞서 했던 것과 마찬가지로 스택에 넣는다. 
만약 1차 인접노드(시작 노드에서 1링크 떨어진)가 2개고 각각 2번, 3번이라고 불리는 노드라고 해보자. 그리고 오름차순으로 노드를 방문한다고 하면, 2번 노드부터 방문해야할 것이다. 
그런데 스택에서 2번 노드를 팝함과 동시에 2번 노드의 인접노드를 스택에 추가한다고 했다. 그러면 3번 노드는 2번노드의 제일 깊은 곳까지 탐색하고 깊은 곳에 있던 노드들이 스택에서 전부 사라져 3번이 스택의 탑이 됐을 때 방문하게 된다. 
이런 특징 때문에 스택의 FILO 구조가 깊이 우선 탐색에 적합한 것이다. 

bfs는 큐를 사용한다. 큐는 FIFO의 특징을 갖고 있는데, 이런 특징이 bfs 구현 자료구조로 선택된 것인지 알아보자. 
bfs는 너비 우선 탐색이지만 레벨이 더 직관적인 것 같다. 일단 하나의 레벨에 도착하면 같은 레벨을 가진 모든 노드를 먼저 방문하고 다음 레벨로 가야한다. 
아까 dfs에서 2번, 3번 노드가 스택에 푸시된다고 했다. 그러면 이 2번, 3번 노드는 같은 레벨이다. 시작 노드를 방문했으니 다음은 2번, 3번 노드를 순차적으로 방문해야한다. 그러면 큐의 입구에서 2번을 빼내면서 2번의 인접 노드들을 큐의 끝으로 푸시한다. 
다음인 3번 노드도 입구로 빼내고 3번의 인접 노드들을 큐의 끝으로 푸시한다. 이렇게되면 같은 레벨인 노드들을 먼저 방문하는 것이 된다. 
편의점의 선입 선출과 같은 구조이다. 우유를 살 때 뒤에서부터 보라는 팁이 있다. 이는 유통기한이 긴 것들은 뒤에부터 놓고, 짧은 것들은 앞에 두기 때문에 더 오래 두고 먹을 수 있는 우유를 구매하기 위한 방법인데, 이 하나의 우유 매대가 bfs의 큐와 같은 방식이다. 

이제 이걸 진짜 코드로 구현해보자.

### graph 만들기 
연결된 노드 쌍이 한줄씩 입력된다. 

- [ ] 빈 2차원 배열을 만든다. (1번 노드의 자식이 2, 3번이라면 이 배열의 1번 인덱스에 [2, 3] 형태로 추가하기 위해 2차원 배열을 만드는 것)
- [ ] 노드 쌍을 한 줄씩 읽으며 서로의 인덱스(그래프)에 인접 노드를 push한다.

### dfs 만들기

- [ ] 인접 노드를 알아야하기 때문에 그래프를 인자로 받는다.
- [ ] 시작 노드는 다를 수 있으므로 시작 노드도 인자로 받는다.
- [ ] 탐색에 사용하기 위한 스택과, 이미 방문했음을 알기 위한(그래프는 쌍방 연결이므로 중복 방문이 있을 수 있다. 서로가 서로의 자식..) 방문 여부 배열을 만든다.
- [ ] 시작 노드를 스택에 푸시
- [ ] 스택이 빌 때까지 dfs 탐색을 반복한다.
- [ ] 스택의 탑을 이미 방문했다면 그냥 팝, 방문하지 않았었다면 인접 노드들을 스택에 푸시하고, 방문 여부를 표시한 후에 팝한다. (팝하는건 동일)

 ### bfs 만들기

- [ ] 인접 노드를 알아야하기 때문에 그래프를 인자로 받는다.
- [ ] 시작 노드는 다를 수 있으므로 시작 노드도 인자로 받는다.
- [ ] 탐색에 사용하기 위한 큐와, 이미 방문했음을 알기 위한(그래프는 쌍방 연결이므로 중복 방문이 있을 수 있다. 서로가 서로의 자식..) 방문 여부 배열을 만든다.
- [ ] 시작 노드를 큐에 푸시
- [ ] 큐가 빌 때까지 bfs 탐색을 반복한다.
- [ ] 큐의 0번을 이미 방문했다면 그냥 shift, 방문하지 않았었다면 인접 노드들을 큐에 푸시하고, 방문 여부를 표시한 후에 shift한다. (팝하는건 동일)




